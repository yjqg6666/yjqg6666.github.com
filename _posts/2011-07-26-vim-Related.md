---
layout: default
title: [转载]vim-相关知识收集
published: true
category: vim
tags: [vim,相关]
---
<div id="detail" class="detail" style="line-height: 1.3;"><p>＜quote&gt;<br>ncw或nCW：修改指定数目的字<br>nCC：修改指定数目的行<br><br>删除命令<br>ndw或ndW：删除光标处开始及其后的n-1个字<br>do：删至行首<br>d$：删至行尾<br>ndd：删除当前行及其后n-1行<br>x或X：删除一个字符，x删除光标后的，而X删除光标前的<br>Ctrl+u：删除输入方式下所输入的文本<br><br>搜索及替换命令 :<br>/pattern：从光标开始处向文件尾搜索pattern<br>?pattern：从光标开始处向文件首搜索pattern<br>n：在同一方向重复上一次搜索命令<br>N：在反方向上重复上一次搜索命令<br>：s/p1/p2/g：将当前行中所有p1均用p2替代<br>：n1,n2s/p1/p2/g：将第n1至n2行中所有p1均用p2替代<br>：g/p1/s//p2/g：将文件中所有p1均用p2替换<br><br>选项设置<br>all：列出所有选项设置情况<br>term：设置终端类型<br>ignorance：在搜索中忽略大小写<br>list：显示制表位(Ctrl+I)和行尾标志（$)<br>number：显示行号<br>report：显示由面向行的命令修改过的数目<br>terse：显示简短的警告信息<br>warn：在转到别的文件时若没保存当前文件则显示NO write信息<br>nomagic：允许在搜索模式中，使用前面不带“”的特殊字符<br>nowrapscan：禁止vi在搜索到达文件两端时，又从另一端开始<br>mesg：允许vi显示其他用户用write写到自己终端上的信息<br><br>最后行方式命令<br>：n1,n2 co n3：将n1行到n2行之间的内容拷贝到第n3行下<br>：n1,n2 m n3：将n1行到n2行之间的内容移至到第n3行下<br>：n1,n2 d ：将n1行到n2行之间的内容删除<br>：w ：保存当前文件<br>：e filename：打开文件filename进行编辑<br>：x：保存当前文件并退出<br>：q：退出vi<br>：q!：不保存文件并退出vi<br>：!command：执行shell命令command<br>：n1,n2 w!command：将文件中n1行至n2行的内容作为command的输入并执行之，若不指<br>定n1，n2，则表示将整个文件内容作为command的输入<br>：r!command：将命令command的输出结果放到当前行 。<br><br><br>set expandtab<br>
set shiftwidth=4<br>
set tabstop=4<br>
set softtabstop=4<br>
set nobackup<br>
set cindent<br>
set autoindent<br>
set showcmd<br>
set helplang=Cn<br>
set nofoldenable<br>
set noswapfile<br>
set number<br>
set mouse=nv<br>
set hlsearch<br>
set incsearch<br>
set viminfo+=h<br><br>&lt;/quote&gt;<br><br><br><br>＜quote&gt;<br>im编辑器有许多设定选项的方法.一般情况下要设定一个选项,我们可以用下面的命令:<br>　　:set option=value<br>　　这样的设置方法是在大多数的情况下都可以很好的来工作的.真值选项的设置可以用下面的命令:<br>　　:set option<br>　　如果要重置我们可以用下面的命令:<br>　　:set nooptoion<br>　　如果我们要查看一个选项的值,我们可以用这样的命令:<br>　　:set option?<br>　　如果我们要将一个选项设为其默认的值,我们可以用下面的命令来做到:<br>　　:set option&amp;<br>　　布尔选项:<br>　　我们可以对布尔选项执行下面的操作:<br>　　:set option 打开选项<br>　　:set nooption 关闭选项<br>　　:set option! 转换选项<br>　　:set invoption 转换选项<br>　　:set option&amp; 将选项设为默认值<br>　　例如:<br>　　:set list<br>　　:set list?<br>　　list<br>　　:set nolist<br>　　:set list?<br>　　nolist<br>　　:set list!<br>　　:set list?<br>　　list<br>　　:set list&amp;<br>　　:set list?<br>　　nolist<br>　　数字选项:<br>　　我们可以对数字选项执行下面的一些操作:<br>　　:set option += value 在选项中加入一个值<br>　　:set option -= value 在选项中减去一个值<br>　　:set option ^= value 将值乘以选项<br>　　:set option&amp; 将选项设为默认值<br>　　例如:<br>　　:set shiftwidth=4<br>　　:set shiftwidth += 2<br>　　:set shiftwidth?<br>　　shiftwidth=6<br>　　:set shiftwidth-=3<br>　　:set shiftwidth<br>　　shiftwidth=3<br>　　:set shiftwidth ^= 2<br>　　:set shiftwidth<br>　　shiftwidth=6<br>　　:set shiftwidth&amp;<br>　　:set shiftwidth<br>　　shiftwidth=8<br>　　字符串相关的命令:<br>　　我们可以对字符串选项执行下面的操作:<br>　　:set option += value 在选项的末尾加上value<br>　　:set option -= value 从选项中移去value或是字符<br>　　:set option ^= value 在选项的开头加入value<br>　　例如:<br>　　:set cinwords=test<br>　　:set cinwords?<br>　　cinwords=test<br>　　:set cinwords+=end<br>　　:set cinwords?<br>　　cinwords=test,end<br>　　:set cinwords-=test<br>　　:set cinwords?<br>　　cinwords=end<br>　　:set cinwords^=start<br>　　:set cinwords?<br>　　cinwords=start,end<br>　　下面的命令会设置一个布尔选项(例如list或是nolist),但是他会显示出其他类型选项的值::set option<br>　　然而用这样的命令方式来显示一个选项的值并不是很好的方法,因为如果我们不小心这个方法就会导致错误.更好的方法是用下面的命令来显示一个选项的值:<br>　　:set option?<br>　　相对的下面的命令形式:<br>　　:set option = value<br>　　查看其值的方法为:<br>　　:set option:value<br>　　其他的一些:set参数:<br>　　下面的命令会打印出所有的与其默认值不同的选项:<br>　　:set<br>　　下面的命令会打印出所有的选项:<br>　　:set all<br>　　下面的命令会打印出终端控制代码:<br>　　:set <a href="http://en.wikipedia.org/wiki/Termcap" class="ml-smartlink" target="_blank" target="_blank">termcap</a><br>　　最后如果我们要将所有的选项都重新置为默认值我们可以用下面的命令:<br>　　:set all&amp;<br>　　我们可以在一行中放入几个:set操作.例如要设置三个不同的选项我们可以用下面的命令:<br>　　:set list shiftwidth=4 incsearch<br>　　在一个文件中自动设置选项:<br>　　我们可以在我们的文件中放入Vim设置.当我们启动Vim编辑一个文件时,他会读入这个文件中的最初几地并查找如下格式的行:<br>　　vim:set option-command option-command option-command...<br>　　这样的行被称为模式行(<a href="http://en.wikipedia.org/wiki/XFree86_Modeline" class="ml-smartlink" target="_blank" target="_blank">modeline</a>)<br>　　例如在一个程序中一个模式行如下:<br>　　/*vim:set shiftwidth=4 autoindent:*/<br>　　相对的格式如下:<br>　　Vim:option-command:option-command:....<br>　　选项<a href="http://en.wikipedia.org/wiki/XFree86_Modeline" class="ml-smartlink" target="_blank" target="_blank">modeline</a>可以打开或是关闭这种行为.选项modeline可以控制Vim在查找设置命令时会读入开始的几行.<br>　　例如如果我们设置了下面的选项,Vim就不会查找模式行了:<br>　　:set nomodeline<br>　　如果我们设置了下面的选项,Vim就会在每一个文件的头部或是尾部查找由modeline选项所指定的行数:<br>　　:set modeline<br>　　例如也许我们都会在Vim的帮助文件的末尾看到下面的几行:<br>　　vim:tw=79:ts=8:sw=8:<br>　
　在这个设置中是将tw(textwidth)选项设为78,ts(tabstop)选项设为8,sw(shiftwidth)选项设为8.这样的设置使
得我们的帮助文件看起来更好看一些.通过使用模式行,帮助文件的制造者就会确保这些文本可以被正确的格式化而不论我们在其他的文件中使用怎么样的本地设
置.<br>　　.vimrc文件:<br>　　假如我们要对每一个不同的目录进行不同的设置,一个办法就是在每一个目录中放入.vimrc或是.gvimrc文件.然而这样做还是不够的,因为默认的Vim会忽略这些文件.<br>　　要使得Vim读入这些文件,我们必须执行下面的命令:<br>　　:set exrc<br>　　进行这样的设置却存在着安全问题.毕竟一些不成功的命令是很容易加入到这些文件中的,即使我们是在其他的目录中进行我们的编辑工作,这样的设置也会影响我们的.<br>　　为了避免安全问题,我们可以用下面的命令来设置安全选项:<br>　　:set secure<br>　　这个选项会阻止当前目录下的初始文件中的:autocommand,:write,:shell命令的执行.<br>　　自定义键盘的使用:<br>　　大多数运行在Windows平台下的程序会使用Alt键来选择菜单内容.然后Vim希望能用所有的键来完成我们的命令.选项winaltkeys可以控制Alt键的使用.<br>　　例如,如果我们执行了下面的命令,所有的Alt键就可以通过:map命令来使用之成我们命令中的一部分:<br>　　:set winaltkeys=no<br>　　执行Alt-F并不会选择文件菜单而是执行映射的Alt-F命令.这个可以映射可以是下面的样子:<br>　　:map &lt;M-f&gt; :write<br>　　在这里我们要知道的就是在Vim中Alt会被叫作M-,Meta的意思.<br>　　如果我们执行了下面的命令,所有的Alt键盘就会选择菜单内容而不会执行映射命令了:<br>　　:set winaltkeys=yes<br>　　第三个选项是yes和no的组合:<br>　　:set winaltkeys=menu<br>　　在这种模式下,Alt键可以用于选择菜单,也可以用来映射:map命令.所以Alt-F可以选择文件菜单,而我们还可以用Alt-X来映射命令.<br>　　我们可以有两个选项来控制当我们使用字符界面的Vim时如何来读入键盘.下面的选项会告诉Vim直接由控制台读入:<br>　　:set conskey<br>　　如果我们希望Vim编辑器从标准的输入读入脚本文件时不要用这个选项.<br>　　下面的选项会告诉Vim使用BIOS来读入键盘:<br>　　:set bioskey<br>　　在这里我们也要指出的就是如果我们要使用重定向的脚本也不要设置这样的选项.通过指定Vim使用BIOS,我们就会得到更快的CTRL-C的响应以及Break中断.<br>　　自定义键盘映射:<br>　　大多数的Unix功能键会发出由&lt;Esc&gt;开始的字符串.但是这样却存着一个问题,那就是&lt;Esc&gt;键是用来结束插入模式的.所以我们如何在插入模式下处理功能键呢?<br>　　Vim的一个解决办就是在按下&lt;Esc&gt;以后等待一会看是否还会有其他的字符输入.如果是这样的,Vim就会知道按下了功能键并会执行相应的操作.要打开这个特征我们可以执行下面的命令:<br>　　:set esckeys<br>　　但是如何来处理其他键的顺序呢?我们可以通过下面的两个选项来控制区:<br>　　:set timeout<br>　　:set ttimeout<br>　　下面的是这些设置的作用:<br>　　timeout ttimeout 结果<br>　　notimeout nottimeout 没有超时<br>　　timeout N/A 所有的代码键(&lt;F1&gt;...)以及:map宏超时.<br>　　notimeout ttimeout 只有代码键超时<br>　　选项timeoutlen决定在按下Esc后等待多长时间来决定是否还有输入.默认值为1秒:<br>　　:set timeoutlen=1000<br>　　一般情况下,timeoutlen选项控制功能键以及键盘映射的等待时间.如果我们希望键盘映射使用不同的时间,我们可以用ttimeout选项:<br>　　:set ttimeout=500<br>　　这两个选项是告诉Vim在Esc按下后等待1/2秒来决定我们是否还会输入功能键或是等待1秒来决定是否还有其他的键盘映射输入.<br>　　确认:<br>　　在一般的情况下,我们会遇到一些Vim认为有疑问的事情,如从一个已修改的缓冲区退出,命令失败.如果我们设置confirm选项,Vim在类似的情况下就会显示出一个确认的对话框:<br>　　:set confirm<br>　　这样当我们试着在一个已经修改的缓冲区中执行:quit命令时就会显示一个要我们来确认的对话框.<br>　　自定义消息:<br>　　Vim通常使用屏幕下部来显示消息.有时这样的消息会超出一行而且我们会得到类似于按回车继续的提示.为了避免这样的提示,我们可以通过设置cmdheight选项来增加消息的行数.例如我们可以用下面的命令来使得消息的空间设为3:<br>　　:set cmdheight=3<br>　　显示状态:<br>　　当我们设置了showmode选项,Vim编辑器就会在屏幕的下部显示出我们当前所处的状态.要设置成这样的模式,我们可能使用下面的命令:<br>　　:set showmode<br>　　显示部分命令:<br>　　如果我们设置了showcmd选项,当我们输入命令时就会在屏幕的下部显示出部分命令.例如我们执行下面的命令:<br>　　:set showcmd<br>　　现在我们输入fx命令来查找x.当我们输入f时就会在底部显示f.<br>　　这对于我们输入较为复杂的纵使时就会显示尤为有用.<br>　　在一般的情况下,当我们执行了:shell命令时Vim就会警告我们文件已修改.如果我们要关闭这个选项,我们可以执行下面的命令:<br>　　:set nowarn<br>　　当Vim捕获一个错误时,他只是会显示出一个错误信息.如果我们要打开声音警告我们可以执行下面的命令:<br>　　:set errorbells<br>　　但是有时这样的设置会影响我们的其他的同事,在这样的情况下我们可以来设置visualbell选项.这样当我们输入错误时屏幕就会闪动然后回到正常状态.要设置这样的选项我们可以执行下面的命令:<br>　　:set visualbell<br>　　我们还可以自定义状态行.我们可以使用下面的选项来定义我们的状态行:<br>　　:set statusline=format<br>　　%用来指明一个特殊的区域.例如%f来告诉Vim在状行中包含文件名.如下面的命令:<br>　　:set statusline=The/ file/ is//"%f/"<br>　　这时的状态行为:<br>　　The file is "sample.txt"<br>　
　我们可以指定一个内容的最大和最小的宽度.例如下面的命令告诉Vim编辑器文件至少为8个字符但是最多为19个字符.这些内容是右对齐的,如果我们希望
他们能左对齐,我们可以在%后面加上-.数字的内容是忽略开头的0来显示.如果我们需要我们可以在%后加上一个0.例如我们要显示列数而需要开始的0,我
们可以使用下面的命令:<br>　　:set statusline=%05.10c<br>　　格式,类型以及描述如下:<br>　　%(...%) 定义一个项目组.如果在这个组中的所有的内容均为空,整个组的内容就不会显示.<br>　　%{n}*<br>　　%对其余的行使用高亮显示组Usern,直到看到另一个%n*.格式%0*会使得行成为正常的高亮显示.如果高亮显示组User1带有下划线(:set statusline=File:/%1*%f%0).这时状态行显示的文件名就会带有下划线.<br>　　%&lt; 定义如果状态行过长在何处换行<br>　　%=<br>　　定义在一行中部的某处.所有向左的字符串放在这行的左部,而向右的字符串放在一行中靠近右边的部.<br>　　% 字符%<br>　　%B 光标下字符的十六进制形式<br>　　%F 全路径的文件名<br>　　%H 如果为帮助缓冲区则为HLP<br>　　%L 缓冲区中的行数.<br>　　%M 如果缓冲区修改过则显示为+<br>　　%O 以十六进制方式显示文件中的字符偏移<br>　　%P 文件中光标前的%<br>　　%R 如果缓冲区只读则为RO<br>　　%V 列数.如果与%c相同则为空字符串<br>　　%W 如果窗口为预览窗口则为PRV<br>　　%Y 文件类型<br>　　a%(字符串) 如果我们在编辑多行文本,这个字行串就是"({current} of<br>　　{arguments})".例如:(5 of 18).如果在命令行中只有一行,这个字符串为空.<br>　　%b(数字) 光标下的字符的十进制表示形式.<br>　　%c(数字) 列号<br>　　%f(字符串) 在命令行中指定的文件名<br>　　%h(标记) 如果为帮助缓冲区为[Help]<br>　　%l(数字) 行号<br>　　%m(标记) 如果缓冲区已修改则表示为+<br>　　%n(数字) 缓冲区号<br>　　%o(数字) 在光标前的字符数,包括光标下的字符<br>　　%p(数字) 文件中所在行的百分比<br>　　%r(标记) 如果缓冲区为只读则表示为RO<br>　　%t(字符串) 文件名(无路径)<br>　　%v(数字) 虚列号<br>　　%w(标记) 如果为预览窗口则显示为Preview<br>　　%y(标记) 我们输入的文件类型<br>　　%{expr%} 表达式的结果<br>　　标记的内容会被特殊的对待.多行标记,例如RO和PRV,则会自动的由逗号来分隔.而例如+和help则会由空格来分隔.例如:<br>　　:set statusline=%h%m%r<br>　　如果我们并不喜欢默认的状态行,我们可以打开标尺选项(ruler option):<br>　　:set ruler<br>　　这个可以使得Vim显示类似于下面的状态行:<br>　　help.txt [help][RO] 1,1 Top<br>　　在文件名和标记后会显示出当前的列号,虚列号,并且会显示我们在文件中所处的位置.<br>　　如果我们要定义我们自己的标尺格式,我们可以用下面的命令:<br>　　:set rulerformat=string<br>　　这里的string就是我们在statusline选项用到的.<br>　　当我们删除或是修改了一些行的文本,如果这些行数超出了report所指定的行数,Vim编辑器就会告诉这一些情况.所以如果我们要Vim报告所有的变化,我们可以用下面的命令:<br>　　:set report=0<br>　　相反,如果我们不希望Vim来告诉我们这些变化,我们可以将这个值设成一个相当大的值就可了.<br>　　我们可以用下面的命令来设置帮助窗口的最小尺寸:<br>　　:set helpheight={height}<br>　　我们这里设置的数值会在打开帮助窗口时用到.<br>　　我们也可以用下面的命令来设置预览窗口的大小:<br>　　:set previewheight={height}<br>　　在一般的情况下,list命令使用^I来表示Tab而使用$来表示一行的结尾.我们也可以自定义这种形为.我们可以使用listchars选项来定义list模式如何工作.这个命令的格式如下:<br>　　:set listchars=key:string,key:string<br>　　而key:string可以用到的值如下:<br>　　eol:{char} 定义放在一行结尾处的字符<br>　　tab:{char1}{char2} 一个Tab值为char1和char2的组合来表示.<br>　　trail:{char} 用来表示结尾空格的字符.<br>　　extends:{char} 用来表示一行的结尾和下一行连接的字符<br>　　我们可以使用highlight选项来改变许多对象的高亮显示.这个选项的格式如下:<br>　　:set highlight=key:group,[key:group]...<br>　　我们可以使用下面的key值:<br>　　key Default Meaning<br>　　8 SpeicalKey 当用:map命令列出特殊键时用来高亮显示<br>　　@ NonText Vim用~和@来表示不在缓冲区中的内容时适用.<br>　　M Modemsg 在屏幕下部显示的模式信息.<br>　　S StatusLineNC 除当前窗口外的每一个窗口的状态行.<br>　　V VisualNOS 可视化模式下选择的文本.<br>　　w WildMenu 作为通配符的一部分而显示<br>　　d Directroy 当我们按下CTRL-D时显示的目录<br>　　e ErrorMsg 错误信息.<br>　　i IncSearch 作为增量查找的一部分而显示<br>　　I Search 作来查找的一部分而显示<br>　　m MoreMsg --More--提示<br>　　n LineNr 由命令:number打印出的行号<br>　　r Question 按下回车的提示及其他的问题<br>　　s StatusLine 当前窗口的状态行<br>　　t Title 输入信息的命令标题.<br>　　v Visual 在可视化模式下选择的文本<br>　　w WaringMsg 警告信息.<br>　　我们还可以使用缩写字符:<br>　　r Reverse<br>　　i Italic<br>　　b Bold<br>　　s Standout<br>　　u Underline<br>　　n None<br>　　- None<br>　　所以我们可以通过下面的命令来使用ErrorMsg组来高亮显示错误信息:<br>　　:set highlight=e:ErrorMsg<br>　　或者我们可以通过下面的命令来以reverse,bold,italic方式来显示错误:<br>　　:set highlight=ervb<br>　　如果我们设置了more选项,当一个命令的显示会超出一屏时就会显示More提示.如果没有进行设置只是会翻滚屏幕.默认如下:<br>　　:set more<br>　　下面的命令定义了可以由CTRL-A,CTRL-X识别的数字格式.<br>　　:set nrformats=octal,hex<br>　　(注:十进制总是可以识别)<br>　　如果我们设置了下面的选项,Vim就会试着重新装入终端屏幕的内容.<br>　　:set restorescreen<br>　　换句话说,他会试着使得我们运行这个程序以后的屏幕看起来就像他运行以前的一样.<br>　　xterm可以允许我们按下鼠标左键拉动时选择文本.这个文本可以粘贴到其他的窗口中.然后一些由于兼容的问题会使得我们在粘贴文本时出现问题.为了避免这样的问题,我们可以使用下面的命令来设置粘贴模式:<br>　　:set paste<br>　　然而有时我们希望是粘贴模式而有时希望不是.pastetoggle选项可以使得我们定义一个键在这两种模式中进行切换.例如,如果我们使用F12键进行切换,我们可以用下面的命令:<br>　　:set pastetoggle=&lt;F12&gt;<br>　　当关闭粘贴模式时,所以的选项就会恢复到先前的值.<br>　　当我们在ex模式下输入命令时,我们可以实现文件名的自动完成.例如如果我们想要读入文件input.txt,我们可以输入下面的命令:<br>　　:read input&lt;Tab&gt;<br>　　Vim就会试着猜出我们想要的文件.如果在我们当前的目录下只有文件input.txt,他就会显示出如下的形式:<br>　　:read input.txt<br>　　如果在当前目录下有几个带有input的文件名,则会显示第一个.如果我们再按下Tab,就会显示出第二个相匹配的结果,再按下Tab就会显示第三个.<br>　　我们可以通过下面的命令来定义完成通配符的键:<br>　　:set wildchar=character<br>　　如果我们是在一个宏内使用文件名,我们要设置wildcharm.这是我们在宏内完成文件名自动完成的字符.例如下面的命令:<br>　　:set wildcharm=&lt;F12&gt;<br>　　:map&lt;F11&gt; :read in&lt;F12&gt;<br>　　这样当我们按下F11时就会读入文件命令.<br>　　也许我们并不希望匹配备份文件或是其他类似的文件.我们可以用下面的命令来告诉Vim哪些是这样的文件:<br>　　:set wildignore=pattern,pattern<br>　　这样与指定类型相匹配的文件都会被忽略掉.例如我们要忽略目录文件和备份文件,我们可以用下面的命令:<br>　　:set wildignore=*.o,*.bak<br>　　suffixes选项会列出一系列文件名的前缀,当遇到这样的前缀时就会得到一个较低的优先级.换句说就是如果一个文件名有这样的前缀就会在匹配时就会一个来显示.<br>　　一般情况下,文件名的完成代码并不会显示一个匹配列表.如果我们设置下面的选项:<br>　　:set wildmenu<br>　　当我们试着要完成一个文件名时,就会在窗口的状态行显示一个可能的文件菜单.<br>　　我们可以通过方向键来完成选择.在一行最末的&gt;表明在右部有更多的选择.下键可以使得编辑器进入一个目录.上键回到父目录,回车选择项目.<br>　　我们可以通过使用wildmode选项来自定义文件完成功能的行为.下面的命令使得Vim只完成第一个的匹配:<br>　　:set wildmode=<br>　　如果我们一直按下wildchar键,则只会显示第一个匹配的结果.<br>　　而下面的命令则会用他可以查找到的第一个文件来完成文件名:<br>　　:set wildmode=full<br>　　这样以后,如果我们一直按下wildchar键,其他的匹配文件就会按顺序来显示.<br>　　下面的命令则会匹配最长的子串:<br>　　:set wildmode=longest<br>　　当我们执行下面的命令时会完成同样的功能,但是只是显示那些位于wildmenu中的文件:<br>　　:set wildmode=longest:full<br>　　下面的命令则会显示一个可能的文件列表:<br>　　:set wildmode=list<br>　　这种模式并不会匹配完成.如果我们希望这样的情况,我们可以使用下面的选项:<br>　　:set wildmode=list:full<br>　　最后要完成最长的子串并列出文件,我们可以使用下面的选项:<br>　　:set wildmode=list:longest<br>　　当我们设置了startofline选项,屏幕的移动命令与一些光标的移动命令例H,M,L,G相同.<br>　　如果我们设置了write选项,我们可以使Vim保存文件.如果我们没有设置这个选项,我们只可以查看文件.如果我们希望Vim作为一个安全的查看者,这样的设置是相当有用的.<br>　　一般情况下,当我们试着保存一个我们不应保存的文件时,Vim就会提示我们使用覆盖选项(!).我们可以告诉Vim总是认为输入了这个选项:<br>　　:set writeany<br>　　但是这样的设置并不是一个很好的选择,因为这样就会覆盖掉以前我们已经存在的文件.<br>　　如果我们要为一个缓冲区设置最大的内存,我们可以用下面的命令:<br>　　:set maxmem={size}<br>　　在这里这个大小是千字节计的.<br>　　为所有的缓冲区定义一个内存容量,我们可以用下面的命令:<br>　　:set maxmemtot={size}<br>　　maxfuncdepth选项可以定义最大的嵌套函数数.相似的,maxmapdepth参数可以定义最大的嵌套映射数.<br>　　下面的内容我们来说一些终端选项:<br>　　我们所使用的终端名存放在term选项中.一般的情况下我们并不需要设置这个选项,因为这个是由我们所使用的Shell和操作的环境来定义的.也许有时我们需要将其读入来允许特定的终端宏.<br>　　对于慢终端(slow terminal)我们可以使用lazyredraw选项.他可以阻止Vim在宏中部重绘屏幕.默认的设置如下:<br>　　:set nolazyredraw<br>　　这个选项已经被现在的终端技术实现.如果我们设置了这个选项,我们就不会看到正在执行的宏.<br>　　在UNIX系统中有一个名为<a href="http://en.wikipedia.org/wiki/Termcap" class="ml-smartlink" target="_blank" target="_blank">termcap</a>的终端控制代码数据库.Vim编辑器同样也有其基本的数据库.如果我们打开了ttybuiltin选项,就会首先搜索这个内在的数据库.<br>　　如果我们设置了ttyfast选项,Vim就会认为我们有一个比较快的终端连接,而且会改变输出来产生一个相对平滑的更新,但是这个有着更多的特征.如果我们有一个慢的连接,我们要重置这个选项.<br>　　ttymouse选项控制终端鼠标代码.这个选项对于试着用终端控制代码来做一些有趣的事时是相当有趣的.例如,如果我们要在控制的输入模式下使用鼠标左键&lt;LeftMouse&gt;和右键&lt;RightMouse&gt;,我们要允许这些选项.<br>　　ttyscroll选项可以控制当屏幕需要更新时要滚动多少行.如果我们在是一个慢的终端上,我们可以将这个选项设为一个较小的值.<br>　　下面的部分我们来说一些在Vim是会少用到的选项.这些选项可以保持与Vi相兼容和支持以前的一些设备.<br>　　下面的选项可以使用Vim尽可能的像Vi一样的运行:<br>　　:set compatible<br>　　与其相类似下面的命令可以使我们与Vi的兼容性相一致:<br>　　:set cpoptions={characters}<br>　　下面的命令可以使得:substitute命令中的g和c选项与UNIX编辑器Ed的用法相类似:<br>　　:set edcompatible<br>　　下面的选项可以设置lisp模式.这个选项可以设置许多的选项来使Lisp编辑更容易.<br>　　:set lisp<br>　　选项tildeop可以使得~与一个运算符相类似.这个与为了Vi的兼容性.如果关闭了这个选项,~命令会选择单一字符情况.用下面的命令,~命令的格式为~motion:<br>　　:set tildeop<br>　　helpfile选项可以定义主帮助文件的位置.如果我们要重置:help命令从哪里得到信息时显得有用.例如:<br>　　:set helpfile=/usr/sdo/vim/my_help.txt<br>　　下面的命令可以提供向后兼容:<br>　　:set weirdinvert<br>　　下面的命令会在每一个字符的输出时产生延时(以毫秒计):<br>　　:set writedelay={time}<br>&lt;/quote url="http://blog.csdn.net/jiangkaibo1987/article/details/4505451"&gt;<br><div><br></div><div><br></div><div><br></div><div>&lt;quote url="http://vimdoc.sourceforge.net/htmldoc/fold.html#Folding"&gt;</div><div><br></div><div><a href="http://vimdoc.sourceforge.net/htmldoc/fold.html#zM" target="_blank">zM</a>		Close all <a href="http://vimdoc.sourceforge.net/htmldoc/fold.html#folds" target="_blank">folds</a>: set <a href="http://vimdoc.sourceforge.net/htmldoc/options.html#%27foldlevel%27" target="_blank">'foldlevel'</a> to 0.
		<a href="http://vimdoc.sourceforge.net/htmldoc/options.html#%27foldenable%27" target="_blank">'foldenable'</a> will be set.关闭所有折叠


							*<a name="zr"></a><b>zr</b>*
<a href="http://vimdoc.sourceforge.net/htmldoc/fold.html#zr" target="_blank">zr</a>		Reduce <a href="http://vimdoc.sourceforge.net/htmldoc/fold.html#folding" target="_blank">folding</a>: Add one to <a href="http://vimdoc.sourceforge.net/htmldoc/options.html#%27foldlevel%27" target="_blank">'foldlevel'</a>.


							*<a name="zR"></a><b>zR</b>*
<a href="http://vimdoc.sourceforge.net/htmldoc/fold.html#zR" target="_blank">zR</a>		Open all <a href="http://vimdoc.sourceforge.net/htmldoc/fold.html#folds" target="_blank">folds</a>.  This sets <a href="http://vimdoc.sourceforge.net/htmldoc/options.html#%27foldlevel%27" target="_blank">'foldlevel'</a> to highest fold level. 打开所有折叠&lt;/quote&gt;</div></p></div>
