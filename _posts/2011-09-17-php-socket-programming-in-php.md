---
layout: default
title: php-socket-programming-in-php
published: true
category: Linux
tags: [php,socket,programming]
---
<div id="detail" class="detail" style="line-height: 1.3;"><p><div>PHP comes with a fairly comprehensive set of functions to create and manipulate socket communications; however, this capability is not enabled by default. Consequently, you may need to recompile your PHP binary with the "--enable-sockets" parameter to activate socket support. Windows users get a pre-built binary with their distribution.</div><div><br></div><div>Let's start with a simple example - a TCP server that accepts a string as input, reverses it and returns it to the client. Here's the code:</div><div>&lt;?</div><div>// set some variables</div><div>$host = "192.168.1.99";</div><div>$port = 1234;</div><div>// don't timeout!</div><div>set_time_limit(0);</div><div>// create socket</div><div>$socket = socket_create(AF_INET, SOCK_STREAM, 0) or die("Could not create</div><div>socket\n");</div><div>// bind socket to port</div><div>$result = socket_bind($socket, $host, $port) or die("Could not bind to</div><div>socket\n");</div><div>// start listening for connections</div><div>$result = socket_listen($socket, 3) or die("Could not set up socket</div><div>listener\n");</div><div>// accept incoming connections</div><div>// spawn another socket to handle communication</div><div>$spawn = socket_accept($socket) or die("Could not accept incoming</div><div>connection\n");</div><div>// read client input</div><div>$input = socket_read($spawn, 1024) or die("Could not read input\n");</div><div>// clean up input string</div><div>$input = trim($input);</div><div>// reverse client input and send back</div><div>$output = strrev($input) . "\n";</div><div>socket_write($spawn, $output, strlen ($output)) or die("Could not write</div><div>output\n");</div><div>// close sockets</div><div>socket_close($spawn);</div><div>socket_close($socket);</div><div>?&gt;</div><div>This is somewhat involved, so an explanation is in order:</div><div><br></div><div>1. The first step here is to set up a couple of variables to hold information on the IP address and port on which the socket server will run. You can set up your server to use any port in the numeric range 1-65535, so long as that port is not already in use.</div><div>&lt;?</div><div>// set some variables</div><div>$host = "192.168.1.99";</div><div>$port = 1234;</div><div>?&gt;</div><div>2. Since this is a server, it's also a good idea to use the set_time_limit() function to ensure that PHP doesn't time out and die() while waiting for incoming client connections.</div><div>&lt;?</div><div>// don't timeout!</div><div>set_time_limit(0);</div><div>?&gt;</div><div>3. With the preliminaries out of the way, it's time to create a socket with the socket_create() function - this function returns a socket handle that must be used in all subsequent function calls.</div><div>&lt;?</div><div>// create socket</div><div>$socket = socket_create(AF_INET, SOCK_STREAM, 0) or die("Could not create</div><div>socket\n");</div><div>?&gt;</div><div>In case you're wondering what this is all about, don't worry too much about it. The AF_INET parameter specifies the domain, while the SOCK_STREAM parameter tells the function what type of socket to create (in this case, TCP).</div><div><br></div><div>If you wanted to create a UDP socket, you could use the following line of code instead:</div><div>&lt;?</div><div>// create socket</div><div>$socket = socket_create(AF_INET, SOCK_DGRAM, 0) or die("Could not create</div><div>socket\n");</div><div>?&gt;</div><div>4. Once a socket handle has been created, the next step is to attach, or "bind", it to the specified address and port. This is accomplished via the socket_bind() function.</div><div>&lt;?</div><div>// bind socket to port</div><div>$result = socket_bind($socket, $host, $port) or die("Could not bind to</div><div>socket\n");</div><div>?&gt;</div><div>5. With the socket created and bound to a port, it's time to start listening for incoming connections. PHP allows you to set the socket up as a listener via its socket_listen() function, which also allows you to specify the number of queued connections to allow as a second parameter (3, in this example).</div><div>&lt;?</div><div>// start listening for connections</div><div>$result = socket_listen($socket, 3) or die("Could not set up socket</div><div>listener\n");</div><div>?&gt;</div><div>6. At this point, your server is basically doing nothing, waiting for incoming client connections. Once a client connection is received, the socket_accept() function springs into action, accepting the connection request and spawning another child socket to handle messaging between the client and the server.</div><div>&lt;?</div><div>// accept incoming connections</div><div>// spawn another socket to handle communication</div><div>$spawn = socket_accept($socket) or die("Could not accept incoming</div><div>connection\n");</div><div>?&gt;</div><div>This child socket will now be used for all subsequent communication between the client and server.</div><div><br></div><div>7. With a connection established, the server now waits for the client to send it some input - this input is read via the socket_read() function, and assigned to the PHP variable $input.</div><div>&lt;?</div><div>// read client input</div><div>$input = socket_read($spawn, 1024) or die("Could not read input\n");</div><div>?&gt;</div><div>The second parameter to socket_read() specifies the number of bytes of input to read - you can use this to limit the size of the data stream read from the client.</div><div><br></div><div>Note that the socket_read() function continues to read data from the client until it encounters a carriage return (\n), a tab (\t) or a \0 character. This character as treated as the end-of-input character, and triggers the next line of the PHP script.</div><div><br></div><div>8. The server now must now process the data sent by the client - in this example, this processing merely involves reversing the input string and sending it back to the client. This is accomplished via the socket_write() function, which makes it possible to send a data stream back to the client via the communication socket.</div><div>&lt;?</div><div>// reverse client input and send back</div><div>$output = strrev($input) . "\n";</div><div>socket_write($spawn, $output, strlen ($output)) or die("Could not write</div><div>output\n");</div><div>?&gt;</div><div>The socket_write() function needs three parameters: a reference to the socket, the string to be written to it, and the number of bytes to be written.</div><div><br></div><div>9. Once the output has been sent back to the client, both generated sockets are terminated via the socket_close() function.</div><div>&lt;?</div><div>// close sockets</div><div>socket_close($spawn);</div><div>socket_close($socket);</div><div>?&gt;</div><div>And that's it - socket creation, in nine easy steps!</div><div><br></div><div><br></div><div><br></div><div>================= &nbsp; from &nbsp; &nbsp;&nbsp;http://www.devshed.com/c/a/PHP/Socket-Programming-With-PHP/ &nbsp;======================</div><div><br></div><div><br></div><div>Comments quoted:</div><div><span class="Apple-tab-span" style="white-space:pre">		</span>&nbsp;&nbsp; &nbsp;</div><div><div>Error processing with "or die()" is OK for desktop testing, but for real applications you have to deal with the errors in the most transparent and resilient way - just stopping with an obscure message is not good enough.</div><div><br></div><div><font class="Apple-style-span" color="#008080">Every function call needs to be checked for success, and the reads and writes need to be able to deal with large amounts of data, zero data, data full of newlines, etc.</font></div></div><div><span class="Apple-tab-span" style="white-space:pre">			</span></div><div><span class="Apple-tab-span" style="white-space:pre"><br></span></div><div><span class="Apple-tab-span" style="white-space:pre">O</span>n the params of socket_create():</div><div><span class="Apple-tab-span" style="white-space:pre">			resource socket_create ( int $domain , int $type , int $protocol )</span></div><div><span class="Apple-tab-span" style="white-space:pre"> </span>&nbsp;$domain = [AF_INET, AF_INET6, AF_UNIX] &nbsp;//AF_UNIX =&gt; Local communication protocol family. High efficiency and low overhead make it a great form of IPC (Interprocess Communication).</div><div>$type = [SOCK_STREAM(tcp), SOCK_RAW, SOCK_DGRAM(udp),SOCK_RDM,SOCK_SEQPACKET] &nbsp;</div><div>$protocol = [SOL_TCT, SOL_UDP, .....] &nbsp; or use int, 1=&gt;icmp &nbsp; ..., &nbsp;The proper value can be retrieved by name by using getprotobyname(), the name by using getprotobynumber().</div><div><br></div><div><br></div><div><a href="http://blog.chinaunix.net/cp.php?ac=blog&amp;blogid=2855393&amp;op=edit" target="_blank">php manual on socket: </a>&nbsp;&nbsp;http://blog.chinaunix.net/cp.php?ac=blog&amp;blogid=2855393&amp;op=edit</div></p></div>
